#!/bin/bash
# Borg
# A container to create backups using Borg.
#
# Copyright (c) 2022  SGS Serious Gaming & Simulations GmbH
#
# This work is licensed under the terms of the MIT license.
# For a copy, see LICENSE file or <https://opensource.org/licenses/MIT>.
#
# SPDX-License-Identifier: MIT
# License-Filename: LICENSE

set -eu -o pipefail
export LC_ALL=C.UTF-8

APP_NAME="$(basename "${BASH_SOURCE[0]}")"
CONTAINER_CONFIG_DIR="/etc/backup"

print_usage() {
    echo "Usage:"
    echo "  $APP_NAME [OPTIONS]... ACTION [ARGUMENTS]..."
}

print_help() {
    print_usage
    echo
    echo "Actions:"
    echo "  init     Initializes an empty Borg repository."
    echo "  create   Creates archives (i.e. actually performs the backup; default action)."
    echo "  check    Verifies the consistency of a Borg repository and its archives."
    echo "  restore  Restores files from a named archive."
    echo "  delete   Deletes archives from a Borg repository."
    echo "  prune    Prunes archives according to the retention policy."
    echo "  compact  Frees repository space by compacting segments."
    echo "  list     Lists all archives in a Borg repository."
    echo "  info     Displays information about a Borg repository or its archives."
    echo "  borg     Runs an arbitrary Borg command."
    echo "  configs  Prints a list of available backup configs."
    echo "  shell    Opens an interactive Bash shell."
    echo "  help     Prints usage info about an action and exits."
    echo
    print_options
}

print_options() {
    echo "Help options:"
    echo "      --help     display this help and exit"
    echo
    echo "Application options:"
    echo "  -v, --verbose               explain what is being done"
    echo "  -c, --config BACKUP_CONFIG  specify the backup config file to use"
    echo
    print_host_options
}

print_host_options() {
    echo "Host options:"
    echo "  -C, --container CONTAINER_CONFIG  specify the container config file to use"
    echo "  -n, --no-block                    don't wait to acquire a lock, bail instead"
}

quote() {
    local QUOTED=""
    for ARG in "$@"; do
        [ "$(printf '%q' "$ARG")" == "$ARG" ] \
            && QUOTED+=" $ARG" \
            || QUOTED+=" ${ARG@Q}"
    done

    echo "${QUOTED:1}"
}

cmd() {
    [ -z "$VERBOSE" ] || echo + "$(quote "$@")" >&2
    "$@"
}

check_path() {
    local FILE="$1" INFO="$2"
    shift 2

    for CHECK in "$@"; do
        case "$CHECK" in
            "-e") [ -e "$FILE" ] || { echo "Invalid $INFO ${FILE@Q}: No such file or directory" >&2; return 1; } ;;
            "-f") [ -f "$FILE" ] || { echo "Invalid $INFO ${FILE@Q}: Not a file" >&2; return 1; } ;;
            "-d") [ -d "$FILE" ] || { echo "Invalid $INFO ${FILE@Q}: Not a directory" >&2; return 1; } ;;
            "-r") [ -r "$FILE" ] || { echo "Invalid $INFO ${FILE@Q}: Permission denied" >&2; return 1; } ;;
            *) echo "Invalid $INFO ${FILE@Q}: Invalid argument" >&2; return 1 ;;
        esac
    done
}

run_borg() {
    # prepare `podman` global options
    local OPTS=()
    OPTS+=( --events-backend "none" )

    # prepare `podman secret create` options
    local SECRET_OPTS=()
    SECRET_OPTS+=( --replace )

    # prepare `podman run` options
    local RUN_OPTS=()
    RUN_OPTS+=( --interactive )
    ! tty --quiet || RUN_OPTS+=( --tty )
    [ -n "$VERBOSE" ] || RUN_OPTS+=( --quiet )

    RUN_OPTS+=( --name "$BACKUP_CONTAINER" )
    RUN_OPTS+=( --replace --rm )

    RUN_OPTS+=( --pull "always" )

    RUN_OPTS+=( --net "slirp4netns" )
    RUN_OPTS+=( --security-opt label="disable" )
    RUN_OPTS+=( --device "/dev/fuse" --cap-add "SYS_ADMIN" )

    while [ $# -gt 0 ]; do
        [ "$1" != "--" ] || { shift; break; }
        RUN_OPTS+=( "$1" )
        shift
    done

    RUN_OPTS+=( --log-driver "none" --sdnotify "ignore" )

    # prepare `podman run` params
    local RUN_PARAMS=()

    RUN_PARAMS+=( --env BACKUP_PATH_HOST="$BACKUP_PATH" )
    RUN_PARAMS+=( --env BACKUP_RESTORE_HOST="$BACKUP_RESTORE" )
    RUN_PARAMS+=( --env BORG_REPO_HOST="$BORG_REPO_LOCAL" )

    RUN_PARAMS+=( --mount type="bind",src="$BACKUP_PATH",dst="/root/borg/backup",ro="true" )
    RUN_PARAMS+=( --mount type="bind",src="$BACKUP_RESTORE",dst="/root/borg/restore" )

    if [ -n "$BORG_REPO_LOCAL" ]; then
        RUN_PARAMS+=( --mount type="bind",src="$BORG_REPO_LOCAL",dst="/root/borg/repo" )
    fi

    RUN_PARAMS+=( --mount type="bind",src="$BACKUP_HOME/cache",dst="/root/.cache/borg" )
    RUN_PARAMS+=( --mount type="bind",src="$BACKUP_HOME/config/backup",dst="/root/.config/backup",ro="true" )
    RUN_PARAMS+=( --mount type="bind",src="$BACKUP_HOME/config/borg",dst="/root/.config/borg" )
    RUN_PARAMS+=( --mount type="bind",src="$BACKUP_HOME/config/ssh",dst="/root/.ssh" )

    # setup and run `podman secret`
    if [ -n "$BACKUP_SECRET" ]; then
        RUN_PARAMS+=( --secret "$BACKUP_SECRET_ID",type="mount",target="borg_pass",uid="0",gid="0",mode="0400" )

        cmd podman secret create "${SECRET_OPTS[@]}" "${OPTS[@]}" "$BACKUP_SECRET_ID" "$BACKUP_SECRET" > /dev/null
        TRAPS_EXIT+=( "podman secret rm $(quote "${OPTS[@]}" "$BACKUP_SECRET_ID") > /dev/null" )
    fi

    # execute `podman run`
    local RUN_EXEC=( podman run "${RUN_OPTS[@]}" "${OPTS[@]}" "${RUN_PARAMS[@]}" "$BACKUP_IMAGE" )

    if [ "$BACKUP_USER" != "$(id -un)" ]; then
        cmd sudo --login --user "$BACKUP_USER" -- "${RUN_EXEC[@]}" "$@"
    else
        cmd "${RUN_EXEC[@]}" "$@"
    fi
}

# prepare cleanup trap
TRAPS_EXIT=()

function trap_exit {
    EXIT=$?

    for (( INDEX=${#TRAPS_EXIT[@]}-1 ; INDEX >= 0 ; INDEX-- )); do
        [ -z "$VERBOSE" ] || echo + "${TRAPS_EXIT[$INDEX]}" >&2
        eval "${TRAPS_EXIT[$INDEX]}"
    done

    trap - ERR EXIT
    exit $EXIT
}

trap 'trap_exit' ERR EXIT

# read parameters
CONTAINER_CONFIG="${CONTAINER_CONFIG:-config}"
BACKUP_CONFIG="${BACKUP_CONFIG:-}"
ACTION=""
VERBOSE=""
NO_BLOCK=""

while [ $# -gt 0 ]; do
    if [ "$1" == "--help" ]; then
        print_help
        exit
    elif [ "$1" == "--verbose" ] || [ "$1" == "-v" ]; then
        VERBOSE="yes"
        shift
    elif [ "$1" == "--no-block" ] || [ "$1" == "-n" ]; then
        NO_BLOCK="yes"
        shift
    elif [ "$1" == "--container" ] || [ "$1" == "-C" ]; then
        [ -n "${2:-}" ] || { echo "Missing required argument 'CONTAINER_CONFIG' for option '--container'" >&2; exit 1; }
        CONTAINER_CONFIG="$2"
        shift 2
    elif [ "$1" == "--config" ] || [ "$1" == "-c" ]; then
        [ -n "${2:-}" ] || { echo "Missing required argument 'BACKUP_CONFIG' for option '--config'" >&2; exit 1; }
        BACKUP_CONFIG="$2"
        shift 2
    elif [ "${1:0:1}" == "-" ]; then
        echo "Unknown option: $1" >&2
        exit 1
    elif [ -z "$ACTION" ]; then
        ACTION="$1"
        shift

        break
    fi
done

if [ -z "$ACTION" ]; then
    echo "Missing required argument 'ACTION'" >&2
    echo >&2
    print_usage >&2
    exit 1
fi

# check whether usage info should be printed
PRINT_HELP=""
if [ "$ACTION" == "help" ]; then
    if [ $# -eq 0 ]; then
        print_help
        exit
    fi

    if [ "$1" == "--help" ]; then
        echo "Usage:"
        echo "  $APP_NAME [OPTIONS]... help [ACTION]"
        echo
        print_options
        exit
    fi

    if [ -z "$1" ]; then
        echo "Missing required argument 'ACTION' for action 'help'" >&2
        exit 1
    fi

    PRINT_HELP="yes"
    ACTION="$1"
    shift
elif [ "${1:-}" == "--help" ]; then
    PRINT_HELP="yes"
    shift
fi

# source container config
if ! [[ "$CONTAINER_CONFIG" =~ ^[^/]+$ ]]; then
    echo "Invalid argument 'CONTAINER_CONFIG': $CONTAINER_CONFIG" >&2
    exit 1
fi

CONTAINER_CONFIG_FILE="$CONTAINER_CONFIG_DIR/$CONTAINER_CONFIG.env"
check_path "$CONTAINER_CONFIG_FILE" "container config file" -e -f -r
source "$CONTAINER_CONFIG_FILE"

if [ -z "${BACKUP_IMAGE:-}" ]; then
    echo "Invalid container config file ${CONTAINER_CONFIG_FILE@Q}: Missing required config variable 'BACKUP_IMAGE'" >&2
    exit 1
elif [ -z "${BACKUP_HOME:-}" ]; then
    echo "Invalid container config file ${CONTAINER_CONFIG_FILE@Q}: Missing required config variable 'BACKUP_HOME'" >&2
    exit 1
fi

[[ "$BACKUP_IMAGE" == *:* ]] || [[ "$BACKUP_IMAGE" == *@* ]] || BACKUP_IMAGE="$BACKUP_IMAGE:latest"
[ -n "${BACKUP_CONTAINER_PREFIX:-}" ] || BACKUP_CONTAINER_PREFIX="$(sed -E -e 's/^(.+\/)?([a-z0-9._-]+)(:.+)?(@.+)?$/\2/' <<< "$BACKUP_IMAGE")"

# source backup config
if [ -n "$BACKUP_CONFIG" ]; then
    if ! [[ "$BACKUP_CONFIG" =~ ^[a-zA-Z0-9][a-zA-Z0-9._-]*$ ]]; then
        echo "Invalid argument 'BACKUP_CONFIG': $BACKUP_CONFIG" >&2
        exit 1
    fi

    BACKUP_CONFIG_FILE="$BACKUP_HOME/config/backup/$BACKUP_CONFIG.env"
    check_path "$BACKUP_CONFIG_FILE" "backup config file" -e -f -r
    source "$BACKUP_CONFIG_FILE"
fi

[ -n "${BACKUP_PATH:-}" ] || BACKUP_PATH="$BACKUP_HOME/backup"
[ -n "${BACKUP_RESTORE:-}" ] || BACKUP_RESTORE="$BACKUP_HOME/restore"
[ -n "${BORG_REPO:-}" ] || BORG_REPO="$BACKUP_HOME/repo"
[ -n "${BACKUP_USER:-}" ] || BACKUP_USER="$(id -un)"
[ -v BACKUP_SECRET ] || BACKUP_SECRET=""
[ -n "${BACKUP_LOCK_FILE:-}" ] || BACKUP_LOCK_FILE="$BACKUP_HOME"

# evaluate config
BACKUP_CONTAINER="$BACKUP_CONTAINER_PREFIX"
[ -z "$BACKUP_CONFIG" ] || BACKUP_CONTAINER+="_$BACKUP_CONFIG"
BACKUP_SECRET_ID="${BACKUP_CONTAINER}_pass"

BORG_REPO_LOCAL=""
if ! [[ "$BORG_REPO" =~ ^[a-zA-Z][a-zA-Z0-9.+-]*"://" ]]; then
    BORG_REPO_LOCAL="$BORG_REPO"
elif [ "${BORG_REPO:0:7}" == "file://" ]; then
    BORG_REPO_LOCAL="${BORG_REPO:7}"
fi

# check paths
check_path "$BACKUP_PATH" "backup directory" -e -d
check_path "$BACKUP_RESTORE" "restore directory" -e -d

[ -z "$BORG_REPO_LOCAL" ] \
    || check_path "$BORG_REPO_LOCAL" "Borg repository directory" -e -d

check_path "$BACKUP_HOME/cache" "Borg cache directory" -e -d
check_path "$BACKUP_HOME/config/backup" "backup config directory" -e -d
check_path "$BACKUP_HOME/config/borg" "Borg config directory" -e -d
check_path "$BACKUP_HOME/config/ssh" "SSH config directory" -e -d

[ -z "$BACKUP_SECRET" ] \
    || check_path "$BACKUP_SECRET" "Borg secret" -e -f

# acquire exclusive lock
[ -e "$BACKUP_LOCK_FILE" ] || cmd touch "$BACKUP_LOCK_FILE"

[ -z "$VERBOSE" ] || echo + "exec 9< $(quote "$BACKUP_LOCK_FILE")" >&2
exec 9< "$BACKUP_LOCK_FILE"
TRAPS_EXIT+=( "exec 9<&-" )

if [ -z "$NO_BLOCK" ]; then
    cmd flock 9
elif ! cmd flock -n 9; then
    echo "Failed to acquire lock ${BACKUP_LOCK_FILE@Q}" >&2
    exit 1
fi

# print usage info, if requested
if [ -n "$PRINT_HELP" ]; then
    run_borg -- \
        "backup" "help" "$ACTION"
    echo
    print_host_options
    exit
fi

# run Borg container
CONTAINER_OPTS=()
[ "$ACTION" != "shell" ] || CONTAINER_OPTS+=( --tty )

BACKUP_OPTS=()
[ -z "$BACKUP_CONFIG" ] || BACKUP_OPTS+=( --config "$BACKUP_CONFIG" )
[ -z "$VERBOSE" ] || BACKUP_OPTS+=( --verbose )

run_borg "${CONTAINER_OPTS[@]}" -- \
    "backup" "${BACKUP_OPTS[@]}" "$ACTION" "$@"
exit $?
